{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "83ac36fd-6de3-4382-a3d1-2864a5fb1f14",
   "metadata": {},
   "outputs": [],
   "source": [
    "# auxiliary functions for plotting\n",
    "\n",
    "import os\n",
    "import time\n",
    "from matplotlib import gridspec, pyplot as plt\n",
    "import numpy as np\n",
    "import pytz\n",
    "import torch\n",
    "\n",
    "\n",
    "def create_tests_folder(parent_folder=\"\", prefix=\"\", postfix=\"\"):\n",
    "    \"\"\"\n",
    "    Create tests_folder based on time and change it to Berlin time zone    \"\"\"\n",
    "\n",
    "    time_stamp = int(time.time())\n",
    "    time_zone = pytz.timezone(\"Europe/Berlin\")\n",
    "    test_time = pytz.datetime.datetime.fromtimestamp(time_stamp, time_zone)\n",
    "    test_time = test_time.strftime(\"%Y%m%d-%H%M%S\")\n",
    "    tests_folder = os.path.dirname(os.getcwd()) + f\"/PINN_HardCons/{parent_folder}/test{prefix}_{test_time}{postfix}\"\n",
    "    os.makedirs(tests_folder)\n",
    "    print(f\"\\nWorking in folder {tests_folder}\\n\")\n",
    "    return tests_folder\n",
    "\n",
    "\n",
    "def get_PDE_dataset(domain, N_train_x, N_train_t):\n",
    "    \"\"\"\n",
    "    Generate a training set on the boundary that meets the boundary conditions    \"\"\"\n",
    "\n",
    "    # Training Data\n",
    "    x_min, x_max, t_min, t_max = domain[0], domain[1], domain[2], domain[3]\n",
    "    # x = torch.linspace(x_min + 0.01, x_max - 0.01, N_train_x).view(-1, 1)\n",
    "    # t = torch.linspace(t_min + 0.01, t_max - 0.01, N_train_t).view(-1, 1)\n",
    "    x = torch.linspace(x_min + 0, x_max - 0, N_train_x).view(-1, 1)\n",
    "    t = torch.linspace(t_min + 0, t_max - 0, N_train_t).view(-1, 1)\n",
    "    X, T = torch.meshgrid(x.squeeze(1), t.squeeze(1))\n",
    "    X_pde = torch.hstack((X.transpose(1, 0).flatten().view(-1, 1), T.transpose(1, 0).flatten().view(-1, 1)))\n",
    "    return X_pde\n",
    "\n",
    "\n",
    "def get_BC_dataset(domain, N_bc, case):\n",
    "    \"\"\"\n",
    "    Generate a training set on the boundary that meets the boundary conditions    \"\"\"\n",
    "\n",
    "    # Training Data\n",
    "    x_min, x_max, t_min, t_max = domain[0], domain[1], domain[2], domain[3]\n",
    "    x_bc = torch.linspace(x_min, x_max, N_bc // 4).view(-1, 1) # If u(x,t), then N_bc // 3\n",
    "    t_bc = torch.linspace(t_min, t_max, N_bc // 4).view(-1, 1)\n",
    "    X, T = torch.meshgrid(x_bc.squeeze(1), t_bc.squeeze(1))\n",
    "    if case == \"\":\n",
    "        pass\n",
    "    elif case == \"raw\":\n",
    "        # Initial Condition\n",
    "        # Left Edge: x(x,0)=sin(x)->xmin=<x=<xmax; t=0\n",
    "        left_X = torch.hstack((X[:, 0][:, None], T[:, 0][:, None]))  # First column # The [:,None] is to give it the right dimension\n",
    "        left_Y = torch.sin(np.pi * left_X[:, 0]).unsqueeze(1)\n",
    "        # Boundary Conditions\n",
    "        # Bottom Edge: x=min; tmin=<t=<max\n",
    "        bottom_X = torch.hstack((X[0, :][:, None], T[0, :][:, None]))  # First row # The [:,None] is to give it the right dimension\n",
    "        bottom_Y = torch.zeros(bottom_X.shape[0], 1)\n",
    "        # Top Edge: x=max; 0=<t=<1\n",
    "        top_X = torch.hstack((X[-1, :][:, None], T[-1, :][:, None]))  # Last row # The [:,None] is to give it the right dimension\n",
    "        top_Y = torch.zeros(top_X.shape[0], 1)\n",
    "        # Get all the training data into the same dataset\n",
    "        X_train = torch.vstack([left_X, bottom_X, top_X])\n",
    "        Y_train = torch.vstack([left_Y, bottom_Y, top_Y])\n",
    "    elif case == \"ours\":\n",
    "        # Boundary Conditions\n",
    "        # Top Edge: x2=max; min<x1<max\n",
    "        top_X = torch.hstack((X[:, 0].view(-1, 1), T[:, -1].view(-1, 1)))\n",
    "        top_Y = torch.zeros(top_X.shape[0], 1)\n",
    "        # Bottom Edge: x2=min; min<x1<max\n",
    "        bottom_X = torch.hstack((X[:, 0].view(-1, 1), T[:, 0].view(-1, 1)))\n",
    "        bottom_Y = torch.zeros(bottom_X.shape[0], 1)\n",
    "        # Left Edge: x1=min; min<x2<max\n",
    "        left_X = torch.hstack((X[0, :].view(-1, 1), T[0, :].view(-1, 1)))\n",
    "        left_Y = torch.zeros(left_X.shape[0], 1)\n",
    "        # Right Edge: x1=max; min<x2<max\n",
    "        right_X = torch.hstack((X[-1, :].view(-1, 1), T[0, :].view(-1, 1)))\n",
    "        right_Y = torch.zeros(right_X.shape[0], 1)\n",
    "        # Get all the training data into the same dataset\n",
    "        X_train = torch.vstack([left_X, right_X, bottom_X, top_X])\n",
    "        Y_train = torch.vstack([left_Y, right_Y, bottom_Y, top_Y])\n",
    "    elif case == \"burgers\":\n",
    "        # Initial Condition\n",
    "        # bottom Edge: x(x,0)=-sin(x)->xmin=<x=<xmax; t=0\n",
    "        bottom_X = torch.hstack((X[:, 0].view(-1, 1), T[:, 0].view(-1, 1)))\n",
    "        bottom_Y = -torch.sin(np.pi * bottom_X[:, 0]).unsqueeze(1)\n",
    "        # Boundary Conditions\n",
    "        # Left Edge: x1=min; min<x2<max\n",
    "        left_X = torch.hstack((X[0, :].view(-1, 1), T[0, :].view(-1, 1)))\n",
    "        left_Y = torch.zeros(left_X.shape[0], 1)\n",
    "        # Right Edge: x1=max; min<x2<max\n",
    "        right_X = torch.hstack((X[-1, :].view(-1, 1), T[0, :].view(-1, 1)))\n",
    "        right_Y = torch.zeros(right_X.shape[0], 1)\n",
    "        # Get all the training data into the same dataset\n",
    "        X_train = torch.vstack([left_X, right_X, bottom_X])\n",
    "        Y_train = torch.vstack([left_Y, right_Y, bottom_Y])\n",
    "    elif case == \"heat\":\n",
    "        # Initial Condition\n",
    "        # Left Edge: x(x,0)=sin(x)->xmin=<x=<xmax; t=0\n",
    "        left_X = torch.hstack((X[:, 0][:, None], T[:, 0][:, None]))  # First column # The [:,None] is to give it the right dimension\n",
    "        # left_Y=torch.sin(np.pi*left_X[:,0]).unsqueeze(1)\n",
    "        left_Y = (((left_X[:, 0] - 1) ** 2) * (left_X[:, 0] ** 2) * 1 / 4).unsqueeze(1)\n",
    "        # Boundary Conditions\n",
    "\n",
    "        # Bottom Edge: x=xmin; tmin=<t=<tmax\n",
    "        bottom_X = torch.hstack((X[0, :][:, None], T[0, :][:, None]))  # First row # The [:,None] is to give it the right dimension\n",
    "        bottom_Y = torch.zeros(bottom_X.shape[0], 1)\n",
    "\n",
    "        # Top Edge: x=xmax; tmin=<t=<tmax\n",
    "        top_X = torch.hstack((X[-1, :][:, None], T[-1, :][:, None]))  # Last row # The [:,None] is to give it the right dimension\n",
    "        top_Y = torch.zeros(top_X.shape[0], 1)\n",
    "\n",
    "        # Get all the training data into the same dataset\n",
    "        X_train = torch.vstack([left_X, bottom_X, top_X])\n",
    "        Y_train = torch.vstack([left_Y, bottom_Y, top_Y])\n",
    "    elif case == \"p_lap\":\n",
    "        # Boundary Conditions\n",
    "        # Top Edge: x2=max; min<x1<max\n",
    "        top_X = torch.hstack((X[:, 0].view(-1, 1), T[:, -1].view(-1, 1)))\n",
    "        top_Y = torch.zeros(top_X.shape[0], 1)\n",
    "        # Bottom Edge: x2=min; min<x1<max\n",
    "        bottom_X = torch.hstack((X[:, 0].view(-1, 1), T[:, 0].view(-1, 1)))\n",
    "        bottom_Y = torch.zeros(bottom_X.shape[0], 1)\n",
    "        # Left Edge: x1=min; min<x2<max\n",
    "        left_X = torch.hstack((X[0, :].view(-1, 1), T[0, :].view(-1, 1)))\n",
    "        left_Y = torch.zeros(left_X.shape[0], 1)\n",
    "        # Right Edge: x1=max; min<x2<max\n",
    "        right_X = torch.hstack((X[-1, :].view(-1, 1), T[0, :].view(-1, 1)))\n",
    "        right_Y = torch.zeros(right_X.shape[0], 1)\n",
    "        # Get all the training data into the same dataset\n",
    "        X_train = torch.vstack([left_X, right_X, bottom_X, top_X])\n",
    "        Y_train = torch.vstack([left_Y, right_Y, bottom_Y, top_Y])\n",
    "    return X_train, Y_train\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
